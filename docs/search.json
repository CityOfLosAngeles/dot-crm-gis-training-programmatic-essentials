[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmatic Data Processing Essentials for GIS Specialists",
    "section": "",
    "text": "Overview",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "Programmatic Data Processing Essentials for GIS Specialists",
    "section": "",
    "text": "üåü Goal\nEquip GIS Specialists with foundational R programming skills to streamline their data cleaning and preparation, enabling more efficient workflows with ArcGIS Pro for spatial analysis and map creation.\n\n\nüë©üèΩ‚Äçüíª How\nParticipants will learn:\n\nHow to structure R Projects for reproducibility\nWrite R code in RStudio\nApply core tidyverse functions to clean and wrangle messy data\nExplore data visualization using ggplot2\n\nEmphasis will be placed on reshaping data into tidy data - a consistent, tabular structure that makes analysis and visualization easier, especially when working with spatial attributes in ArcGIS Pro.\n\n\nüí° Motivation\nMany GIS professionals rely on Excel or manual, one-off methods for preparing spatial data. These processes can be time-consuming, error-prone, and hard to replicate. R programming is a powerful, scriptable, and repeatable way to handle data preparation, saving time and reducing frustration while promoting reproducible workflows that align with data science best practices.",
    "crumbs": [
      "Overview"
    ]
  },
  {
    "objectID": "installation.html",
    "href": "installation.html",
    "title": "R & RStudio Installation Guide",
    "section": "",
    "text": "1. Install R\nVisit cloud.r-project.org to download the most recent version of R for your operating system. At the time this guide was last updated, version 4.4.3 was the latest.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>R & RStudio Installation Guide</span>"
    ]
  },
  {
    "objectID": "installation.html#install-RStudio",
    "href": "installation.html#install-RStudio",
    "title": "R & RStudio Installation Guide",
    "section": "2. Install RStudio",
    "text": "2. Install RStudio\nWhile R is a programming language, RStudio is a software (often referred to as an IDE, Integrated Development Environment) that provides R programmers with a neat, easy-to-use interface for coding in R. There are a number of IDEs out there, but RStudio is arguably the best and definitely most popular among R programmers.\n\n\n\n\n\n\nYou need both R and RStudio installed\n\n\n\nRStudio will not work without R installed, and you won‚Äôt particularly enjoy using R without having RStudio installed. Be sure to install both!\n\n\n\n\n\n\n\n\n\n\nImage Credit: Exploratory Data Analysis in R, by Manny Gimond\n\n\n\n\nNew install: To install RStudio, visit posit.co/downloads/. Download the free (‚ÄúOpen Source Edition‚Äù) Desktop version for your operating system. Be sure to install the most up-to-date version available.\n\n\n\nLaunch RStudio: Ensure RStudio opens and is running properly.\n\n\n\n\n\n\n\nMac Users: You may need to install command line tools and XQuartz.\n\n\n\n\n\nIf RStudio prompts you to install Command Line Tools upon opening, go ahead and install them.\n\nTo install command line tools (if you‚Äôre not automatically prompted), run xcode-select --install in the RStudio Terminal\nTo install XQuartz, visit xquartz.org\n\nWindows users: Windows machines should already have command line tools installed, and XQuartz is only required for Macs.",
    "crumbs": [
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>R & RStudio Installation Guide</span>"
    ]
  },
  {
    "objectID": "r-projects.html",
    "href": "r-projects.html",
    "title": "2¬† R Projects",
    "section": "",
    "text": "How Code Finds Stuff (From Data to Files to Images)\nThere are two types of paths in computing: absolute paths and relative paths.\nAn absolute path is the full path to a file or directory, starting from the root directory of the file system. It tells the system exactly where a file or folder is located, no matter where you are in the file structure.\nA relative path specifies a file or directory location in relation to the current working directory (where you are in the file system when running the command or script).",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>R Projects</span>"
    ]
  },
  {
    "objectID": "r-projects.html#how-code-finds-stuff-from-data-to-files-to-images",
    "href": "r-projects.html#how-code-finds-stuff-from-data-to-files-to-images",
    "title": "2¬† R Projects",
    "section": "",
    "text": "On Windows, the absolute path starts with a drive letter: C:\\Users\\Halina\\Documents\\training\\data\\raw_data.csv\nOn Unix/Linux/macOS, the absolute path starts with a root: /home/halina/projects/training/data/raw_data.csv\n\n\n\nIt doesn‚Äôt start with the root or a drive letter\nIt‚Äôs flexible depending on where your program or terminal session is running\nIf you‚Äôre currently in C:\\Users\\Halina\\Documents\\training, the relative path to the raw data file might be: \\data\\raw_data.csv\n\n\n\n\n\n\n\nAbsolute File Paths can break!\n\n\n\n\nlibrary(readr) # load data\nraw_data &lt;- readr::read_csv(\"/home/halina/projects/training/data/raw_data.csv\")\n\nHow would this code break?\n\nIf I was on a different computer or switched user accounts on the same computer. /home/halina/... is an absolute path specific to MY user account on MY computer. Another computer likely won‚Äôt have that same directory structure or username. Other users will have their own home directories, like /home/otheruser/, and won‚Äôt be able to access files in my home folder.\nIf I moved raw_data.csv to a different location on the same computer. Since the path is hardcoded, the code can‚Äôt find the file anymore unless I update the path to reflect the new location.\nIf I shared this with a collaborator. My collaborators would not be able to run it because they don‚Äôt have /home/halina/ on their computers.\nIf I shared this with someone on a Windows computer. It may break because absolute file paths are formatted differently across operating systems. My Mac uses /Users/... or /home/..., while Windows uses C:/Users/..., so the hardcoded path wouldn‚Äôt exist on their system.\n\n\n\n\n\n\n\n\n\nExercise 1\n\n\n\n\n\nLet‚Äôs practice making some file paths!\nConsider the R Project below and answer the following questions:\n\nIf our starting point is scripts, what is the file path to raw_spatial.shp?\nIf our starting point is docs, what is the file path to clean_data.csv?\nIf our starting point is training, what is the file path to raw_data.csv?\n\nNote: To move up one level in the folder hierarchy, use .. in the file path.\n\n\n\n\n\n\n\n\n\n\n\nAnswer:\n\n\nscripts\\..\\training\\data\\raw\\spatial.shp\ndocs\\..\\training\\data\\processed\\clean_data.csv\ntraining\\data\\raw\\raw_data.csv",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>R Projects</span>"
    ]
  },
  {
    "objectID": "r-projects.html#robust-file-paths-using-r-projects-the-here-package",
    "href": "r-projects.html#robust-file-paths-using-r-projects-the-here-package",
    "title": "2¬† R Projects",
    "section": "Robust File Paths Using R Projects & the here package",
    "text": "Robust File Paths Using R Projects & the here package\n\n\n\n\n\n\nAn R project is a directory (folder) on our local computer, which allows us to work in a self-contained space, streamlines the organization of our work and facilitates collaboration with others.\n\n\n\n\n\nWhen you create an R Project, it sets up a dedicated folder (directory) for your work and creates a hidden file with a .Rproj extension. When you open the project in RStudio, R automatically sets the working directory to this folder (your project‚Äôs ‚Äúhome base‚Äù) making it easy to organize and reference all your code, data, and outputs.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nArtwork by Allison Horst\n\n\n\nWhile R Projects and the .Rproj file enable the use of relative paths, they don‚Äôt address all potential issues with breakable file paths. One challenge when working across different operating systems (Windows, macOS, or Linux) is that file paths can be formatted differently. Windows uses backslashes (\\), while Unix-like systems (macOS/Linux) use forward slashes (/). Also, absolute file paths are tied to your machine‚Äôs file structure, so code that works on your computer might break on someone else‚Äôs.\n\n\nThe here package helps solve this by constructing file paths relative to your project directory‚Äîregardless of your operating system. This makes your code more portable and reproducible.\n\nlibrary(readr) # load data\nlibrary(here)\n\n# avoid absolute paths that only work on your computer\nraw_data &lt;- read_csv(\"C:\\Users\\Halina\\Documents\\training\\data\\raw_data.csv\")\n\n# avoid fragile relative paths like this\nraw_data &lt;- read_csv(\"data\\raw_data.csv\")\n\n# use here::here() for robust, OS-agnostic paths\nraw_data &lt;- read_csv(here::here(\"data\", \"raw_data.csv\"))\n\n\n\n\n\n\n\nExercise 2\n\n\n\n\n\nLet‚Äôs practice creating file paths using here::here()!\nConsider the R Project below, answer the following questions:\n\nIf our starting point is scripts, what is the file path to raw_spatial.shp?\nIf our starting point is docs, what is the file path to clean_data.csv?\nIf our starting point is training, what is the file path to raw_data.csv?\n\nNote: here::here() builds file paths relative to the root of your R Project. In this case, the root is training\\.\n\n\n\n\n\n\n\n\n\n\n\nAnswer:\n\nThe relative paths:\n\ndata\\raw\\spatial.shp\ndata\\processed\\clean_data.csv\ndata\\raw\\raw_data.csv\n\nUsing here():\n\nhere(\"data\", \"raw\", \"spatial.shp\")\nhere(\"data\", \"processed\", \"clean_data.csv\")\nhere(\"data\", \"raw\", \"raw_data.csv\")",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>R Projects</span>"
    ]
  },
  {
    "objectID": "r-projects.html#lets-create-an-r-project",
    "href": "r-projects.html#lets-create-an-r-project",
    "title": "2¬† R Projects",
    "section": "Let‚Äôs Create an R Project",
    "text": "Let‚Äôs Create an R Project\n\n\n\n\n\n\nSteps to Create an R Project\n\n\n\n\nIn the ‚ÄúFile‚Äù menu, select ‚ÄúNew Project‚Äù\nClick ‚ÄúNew Directory‚Äù\nClick ‚ÄúNew Project‚Äù\nUnder ‚ÄúDirectory name‚Äù type: r_training_{LAST_NAME} (i.e.¬†r_training_do-linh)\nLeave ‚ÄúCreate Project as subdirectory of:‚Äù set to ~ (the tilde means ‚Äúhome‚Äù)\nClick ‚ÄúCreate Project‚Äù\n\nRStudio should open your new project automatically after creating it. One way to check this is by looking at the top right corner and checking for the project name.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>R Projects</span>"
    ]
  },
  {
    "objectID": "r-projects.html#r-project-organization",
    "href": "r-projects.html#r-project-organization",
    "title": "2¬† R Projects",
    "section": "R Project Organization",
    "text": "R Project Organization\nA consistent folder structure makes it easier to reproduce work and collaborate with others. While directory organization can vary depending on the project, some common directories include:\n\n\n\ndata: Stores datasets. This folder often contains subdirectories such as:\n\nraw: unaltered, original data files\nprocessed: cleaned or transformed datasets\nmetadata: information describing the data (e.g., data dictionaries)\n\nR or scripts: Contains code for data cleaning, wrangling, or analysis. Some projects prefer scripts if they use multiple programming languages beyond R.\nplots or figs: Stores generated visualizations like plots, graphs, or figures.\ndocs: Includes reports, project summaries, or other documentation relevant to the analysis.\n\n\n\n\n\n\n\n\n\n\n\nThe key is to be consistent and intentional in your organization so others (and future-you) can easily understand and reuse your work.",
    "crumbs": [
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>R Projects</span>"
    ]
  },
  {
    "objectID": "intro-r-programming.html",
    "href": "intro-r-programming.html",
    "title": "Intro to R Programming",
    "section": "",
    "text": "Tour of RStudio\nWhen you first open RStudio, you‚Äôll see the following panes:",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Intro to R Programming</span>"
    ]
  },
  {
    "objectID": "intro-r-programming.html#tour-of-rstudio",
    "href": "intro-r-programming.html#tour-of-rstudio",
    "title": "Intro to R Programming",
    "section": "",
    "text": "R vs RStudio: What‚Äôs the Difference?\n\n\n\nR is a programming language used for statistical computing and data analysis. It provides the core functions and packages needed to perform tasks like data wrangling, modeling, and visualization.\nRStudio, is an Integrated Development Environment (IDE) for R. It offers a user-friendly interface with tools like a script editor, console, environment viewer, and built-in plotting pane, which make coding in R more efficient and organized.\n\n\n\n\n\nLeft Pane: The Console is where R executes your code. You can enter commands directly for immediate feedback, making it ideal for testing individual lines of code, inspecting data structures, or running quick calculations during exploratory data analysis.\nTop-Right: The Environment pane provides a real-time overview of the objects currently stored in your R session, including datasets, functions, and variables. It allows you to monitor your workspace as it evolves and serves as a helpful reference when managing data throughout your workflow.\nBottom-Right: The Tools multipurpose pane gives access to a range of utilities: data visualizations (Plots), your working directory (Files), package documentation and function references (Help), and output previews from R Markdown documents or Shiny applications (Viewer). It is especially useful when combining scripting with documentation or interactive tools.\nTop-Left: The Source pane is where you develop and edit your code and documentation. It supports a variety of file types, including R scripts (.R), R Markdown (.Rmd), Quarto documents (.qmd), and Jupyter Notebooks (.ipynb). This pane allows for building reproducible workflows, writing narrative reports that integrate code and results, or developing interactive notebooks for teaching and analysis. Its tabbed interface allows for easy navigation between multiple files. Note: We don‚Äôt see this pane open in this screenshot, but that‚Äôs because we don‚Äôt have any files open yet!",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Intro to R Programming</span>"
    ]
  },
  {
    "objectID": "intro-r-programming.html#coding-in-the-console",
    "href": "intro-r-programming.html#coding-in-the-console",
    "title": "Intro to R Programming",
    "section": "Coding in the Console",
    "text": "Coding in the Console\n\n\n\n\n\n\nBut first, an important question: where are we?\n\n\n\nWhen you first open RStudio, you‚Äôre placed in your Home directory. You‚Äôll notice this location indicated by the tilde symbol (~) at the top of the Console. This symbol is shorthand for your user‚Äôs home folder and is the starting point for your R session.\nIn the Files pane (bottom-right), you‚Äôll see a visual representation of the contents of your Home directory. You can click through folders and browse your file system from here. However, it‚Äôs important to understand that navigating through the Files pane doesn‚Äôt change your working directory in R. In other words, no matter how deep you click into subfolders, R will still consider your location to be ~ until you explicitly tell it otherwise by opening an R Project.\n\n\nAt its most basic, we can use R as a calculator:\n\n# run each expression in the Console\n2 + 5\n400 / 10\n(6 - 1 + 8) / 3\nsin(pi / 2)\n\nUse the up arrow key to bring back the last code we ran in the Console, in this case: sin(pi / 2). Delete the closing parenthesis and notice what happens.\n\n&gt; sin(pi / 2\n+\n\nThe Console has changed the prompt from &gt; to +. This means R is waiting for more input to complete the command. We often see this when we forget to close a parenthesis, quote, or bracket.\nTo fix this, we can either:\n\nFinish the command by typing the closing parenthesis and pressing Enter, or\nPress Esc to cancel the incomplete command and return to the standard prompt (&gt;).\n\nThe + prompt is a helpful clue when debugging code as it usually means R is expecting more syntax to complete the command.\n\nCreating Objects in R with the Assignment Operator (&lt;-)\nIn R, most of the time you‚Äôll be creating objects and this is done using assignment statements using the assignment operator, &lt;-.\n\n# run this code in the Console\n# human translation of this code: \"object x gets value of 3 * 4\"\nx &lt;- 3 * 4\n\n# after you hit Enter, what happened?\n# call \"x\" to view the value you've assigned it\n\nAssignment statements follow a consistent pattern:\n\nobject_name &lt;- value\n\nYou‚Äôll write a lot of assignments, so it‚Äôs worth getting comfortable with this syntax. While you can use = to assign values, it‚Äôs best to stick with &lt;-. Using = can lead to confusion, especially when calling functions, where = is used to specify arguments.\nTo make typing &lt;- easier, use RStudio‚Äôs built-in keyboard shortcut: Alt + - (minus sign)\nRStudio will insert spaces around &lt;- automatically, which is a great formatting habit. Clean code is easier to read - for you, your future self, and your collaborators. Let your code breathe and use spacing to make your code more understandable:\n\n# write your code like this\nmy_value &lt;- 5\n\n# not like this\nmy_value&lt;-5\nmy_value=5\n\n\n\nNaming Things\nWhen naming objects, observations, data frames, or files make them:\n\nMeaningfulConsistentConciseCode & Coder Friendly\n\n\n\n\n\n\n\n\n\n\n\nSlide credit: Allison Horst EDS 221: Scientific programming essentials for the Bren School‚Äôs Master of Environmental Data Science.\n\n\n\n\n\n\n\n\n\n\n\nSlide credit: Allison Horst EDS 221: Scientific programming essentials for the Bren School‚Äôs Master of Environmental Data Science.\n\n\n\n\n\n\n\n\n\n\n\nSlide credit: Allison Horst EDS 221: Scientific programming essentials for the Bren School‚Äôs Master of Environmental Data Science.\n\n\n\n\n\n\n\n\n\n\n\nSlide credit: Allison Horst EDS 221: Scientific programming essentials for the Bren School‚Äôs Master of Environmental Data Science.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Intro to R Programming</span>"
    ]
  },
  {
    "objectID": "intro-r-programming.html#coding-in-an-r-script",
    "href": "intro-r-programming.html#coding-in-an-r-script",
    "title": "Intro to R Programming",
    "section": "Coding in an R Script",
    "text": "Coding in an R Script\nSo far, we‚Äôve been running code directly in the Console, which is great for quick experimentation. Now let‚Äôs try using an R Script instead.\nAn R Script is simply a plain text file where you can write and save your R code. When you run code from an R Script in RStudio, it behaves just like typing the same commands into the Console. RStudio takes the code and sends it line by line to the Console for execution.\nUsing an R Script is helpful for keeping your work organized, reproducible, and easy to edit or rerun later. It‚Äôs a best practice for writing and saving longer pieces of code or entire analysis workflows.\n\n\n\n\n\n\nCreate an R Script\n\n\n\n\nGo to the File menu in the top-left corner of RStudio.\nSelect New File &gt; R Script from the dropdown options.\n\nRStudio will automatically open a new blank R Script. You‚Äôll notice a new pane appears above the Console - the Source pane! It‚Äôs where you‚Äôll write and edit your R code or documents. This pane only appears when you have a file open in the editor.\n\nSave your new R Script by clicking File &gt; Save (or using the shortcut Ctrl + S or Cmd + S on Mac).\nName the file intro_to_programming.R and save it in your R Project r_training_{LAST_NAME}.\n\n\n\n\nHow to Run Code from an R Script\nRunning code from an R Script works a little differently than running code directly in the Console - you can‚Äôt just press Return or Enter. Instead, you need to send the code from the script (in the Source pane) to the Console, where R will interpret and run it.\nHere are some common ways to do this:\n\nRun a single line of code: Place cursor on the line to run, then press Ctrl + Enter (Windows) or Command + Return (Mac), or click the Run button in the top-right corner of the Source pane.\nRun multiple lines of code: Highlight the block of code you want to run, then use the same shortcut (Ctrl + Enter or Command + Return), or click the Run button.\nTo run the entire script you can either: Press Ctrl + Shift + Enter (Windows) or Command + Shift + Return (Mac), or go to the top menu and choose Code &gt; Run Region &gt; Run All.\n\n\n\n\n\n\n\nR Executes Code from Top to Bottom\n\n\n\nWhen you run an entire R Script, R reads it from top to bottom, line by line. This means the order of your code matters‚Äîobjects must be created before they‚Äôre used, and functions must be defined before you call them. Keeping your script well-organized and logically ordered is key to avoiding errors.\n\n\n\n\nR Calculations with Objects\nSo we know that objects are how R stores information, and we know we create objects using the assignment operator &lt;-. Let‚Äôs build upon that and learn how to use an object in calculations.\nImagine we hired a taxi and after the trip, paid a fare of $18.75. Let‚Äôs create an object for the taxi fare and assigned it the total fare paid.\n\n# total taxi fare\ntaxi_fare &lt;- 18.75\n\nNow that R has taxi_fare saved in the Global Environment, we can run calculations with it.\n\n\n\n\n\n\nExercise 1\n\n\n\nAdd a 15% tip to the taxi fare total.\n\n\nAnswer:\n\n\ntaxi_fare * 1.15\n\n[1] 21.5625\n\n\n\n\n\nYou‚Äôre not limited to storing just one value in an object - you can also store a series of values, which allows you to apply the same operation across all of them at once. This is especially useful when working with related measurements, like a group of taxi fares.\nTo create an object that holds multiple values, we use the c() function, which stands for combine or concatenate. Let‚Äôs use it to make a vector of taxi fares:\n\n# vector of taxi fares\ntaxi_fares &lt;- c(18.75, 15.38, 20.42)\n# call object to inspect\ntaxi_fares\n\nWe‚Äôll dive deeper into vectors in the upcoming Data Structures in R section.\n\n\n\n\n\n\nExercise 2\n\n\n\nLet‚Äôs add a 15% trip to all the fares.\n\n\nAnswer:\n\n\ntaxi_fares * 1.15\n\n[1] 21.5625 17.6870 23.4830\n\n\n\n\n\nWhat if we want to use the new values we calculated later? It would be much more efficient to save them instead of repeating the calculation each time.\n\n# create a new object \nfares_with_tip &lt;- taxi_fares * 1.15\n# call `fares_with_tip` to check if the information you expect is there\nfares_with_tip\n\n\n\nLogical operators and expressions\nWe can ask questions about an object using logical operators and expressions. Let‚Äôs ask some ‚Äúquestions‚Äù about the taxi_fare object we made.\n\n== means ‚Äúis equal to‚Äù\n!= means ‚Äúis‚Äù not equal to\n&lt; means ‚Äúis less than‚Äù\n&gt; means ‚Äúis greater than‚Äù\n&lt;= means ‚Äúis less than or equal to‚Äù\n&gt;= means ‚Äúis greater than or equal to‚Äù\n\n\n# examples using logical operators and expressions\ntaxi_fare == 18.75\ntaxi_fare &gt;= 30\ntaxi_fare != 5",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Intro to R Programming</span>"
    ]
  },
  {
    "objectID": "intro-r-programming.html#data-types-in-r",
    "href": "intro-r-programming.html#data-types-in-r",
    "title": "Intro to R Programming",
    "section": "Data Types in R",
    "text": "Data Types in R\nMost common data types we‚Äôll find in R:\n\n\n\n\n\n\n\nData Type\nDefinition\n\n\n\n\nNumeric\nInteger, float, and double are subsets of numeric\nIn general, these are numbers (e.g., 15.7 or -0.98)\nIntegers are whole numbers, created with an L suffix (e.g., 2L).\nFloat and Double are both decimal number types. In R, numbers are usually stored as 64-bit doubles, offering more precision than 32-bit floats. You typically don‚Äôt need to worry about the difference, but floats can be useful when optimizing memory or working with tools that require 32-bit values.\n\n\nCharacter\nNon-numeric letters or symbols and numbers stored as characters (think IDs).\nSequences of characters are typically called strings (e.g., ‚ÄúHello World‚Äù).\n\n\nLogical (Boolean)\nHolds only one of two values: either TRUE or FALSE. Some times these are coded as 0 or 1.\nTemporary logicals are an important part of data wrangling (e.g., matching conditions to subset data).\n\n\nFactor\nDistinct data type for representing categorical variables, levels can be:\n\nordered (ordinal; e.g.¬†education levels [middle school, high school, college] or responses [agree, neutral, disagree], and sometimes year [FY21, FY22, FY23] depending on your analysis),\nunordered (nominal; e.g., color [green, purple, orange] or gender [male, female, non-binary])\n\n\n\n\n\n\n\n\n\n\nLess Common Data Types in R\n\n\n\n\n\n\n(We won‚Äôt be covering these data types)\n\n\n\n\n\n\nData Type\nDefinition\n\n\n\n\nComplex\nThis data type represents numbers that have both real and imaginary parts, such as 2 + 3i. These are useful for mathematical computations involving complex numbers, often seen in engineering and physics.\n\n\nRaw\nThis type stores data as raw bytes, typically used for handling binary data or working with lower-level operations like file manipulation.\n\n\n\n\n\n\n\nCreating & Working with Data Types\n\n\n\n\n\n\nExercise 1: Character Data\n\n\n\n\n\nCreate the character vector and then investigate the object using typeof() and then class().\n\nmicromobility &lt;- c(\"scooter\", \"e-bike\", \"robot delivery devices\")\n\n\n\n\n\n\n\n\n\n\nExercise 2: Numeric Data\n\n\n\n\n\nCreate the numeric vector and then investigate the object using typeof() and then class().\n\nweights &lt;- c(20, 35, 44, 50)\n\nCreate the integer vector and then investigate the object using typeof() and then class().\n\nages &lt;- c(10L, 15L, 21L, 65L)\n\n# check with a logical test\nis.numeric(ages)\n\n\n\n\n\n\n\n\n\n\nExercise 3: Interacting with Different Data Types\n\n\n\n\n\nCopy the code below and run it in the Console. What happened?\n\n\"scooter\" * 20\n\nThis exercise highlights an important concept: In R, objects come in different ‚Äúclasses‚Äù or types, and the operations you can perform depend on the object‚Äôs type. Just like you wouldn‚Äôt use a car to eat soup, you can‚Äôt perform all operations on character objects. Each object type has a specialized format for its specific purpose.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Intro to R Programming</span>"
    ]
  },
  {
    "objectID": "intro-r-programming.html#data-structures",
    "href": "intro-r-programming.html#data-structures",
    "title": "Intro to R Programming",
    "section": "Data Structures in R",
    "text": "Data Structures in R\nWhen we combine multiple data types, we create data structures. We‚Äôre going to discuss three data structures in R: (Atomic) Vectors, Lists, and Data Frames.\n\n1. (Atomic) Vectors\nAn atomic vector is a flat sequence of elements, all of the same type.\nAtomic vectors are the most common type of vector in R, and you‚Äôll encounter them frequently. Vectors serve as the building blocks for many other data structures in R, including data frames.\nProperties of vectors:\n\nType (e.g.¬†character, numeric, logical)\nLength (how many elements in the vector?)\nAttributes (associated metadata)\n\nVectors can only contain a single data type. If different elements are added, the ‚Äúmost flexible‚Äù will be assigned to all elements in the vector.\nData types from least to most flexible are: logical, integer, double, and character.\n\n\n\n\n\n\nExercise 1: Combine Classes\n\n\n\n\n\nCreate the vector and then investigate the object using typeof() and then class().\nRemember there is a hierarchy in R. When combining values into a single vector, R coerces everything to the most flexible (least restrictive) type. If any element is a character, the entire vector will be of type character.\n\nladot_info &lt;- c(\"100 Main St\", 1300, 10L)\n\n# check with a logical test\nis.character(ladot_info)\nis.vector(ladot_info)\n\n\n\n\n\nIndexing Vectors\nIndexing means accessing elements from a data structure.\nFor a vector (or a one-dimensional array), we access an element by position using square brackets [].\nImportant to note that in an R vector, the first element position = 1. This is different from other languages, like python, that use a zero index where the first element in a vector is position = 0.\n\n\n\n\n\n\nExercise 2: Vector Indexing\n\n\n\n\n\nAccess the second element in the micromobility character vector.\n\nmicromobility[2]\n\n\n\n\n\n\n\n2. List\nA list is a flat sequence of objects, each of which can be anything ‚Äî including other lists!\nTo create a list we use the function list():\n\nmetro_bike &lt;- list(\"e-bike\", 29, \"green\", 36L)\n\n# check with a logical test\nis.list(metro_bike)\nis.vector(metro_bike)\n\nUnlike vectors, which require all elements to be of the same type, lists are flexible structures that:\n\nare ideal for storing complex or heterogeneous data types,\nallow each element to be named (helpful for organizing and accessing structured data),\nare often used to return multiple outputs from functions or to store results such as model outputs.\n\n\nIndexing Lists\nLike vectors, list elements can be accessed by their position using square brackets. However, unlike vectors, lists offer two ways to extract elements:\n\nusing a single pair of square brackets [], which returns a list or object,\nor a double pair [[]], which returns the elements within the list.\n\n\n\n\n\n\n\nExercise 3: Index a list\n\n\n\n\n\nCreate the list caltrans_hq, then use square brackets to return the third object and then the elements stored in the third list.\n\ncaltrans_hq &lt;- list(\"Thom Mayne\", c(9L, 10L, 11L), c(\"Caltrans\", \"LADOT\"), 2004)\n# call the list to see how it prints in R\ncaltrans_hq\n\nImportant: a single [] returns a list. [[]] returns the item(s) STORED in the list.\n\ncaltrans_hq[3]\n\ncaltrans_hq[[3]]\n\n\n\n\nIn a named list, you can also access elements by name.\n\n\n\n\n\n\nExercise 4: Named Lists\n\n\n\n\n\nCreate the named list and access the first element using [] and then the subset operator $ or ‚Äúname‚Äù of the list.\n\nnamed_list_caltrans_hq &lt;- list(\n  architect = \"Thom Mayne\",\n  ladot_floors = c(9L, 10L, 11L),\n  departments = c(\"Caltrans\", \"LADOT\"),\n  year_opened = 2004\n)\n\nnamed_list_caltrans_hq\n\n\n# index with square brackets\nnamed_list_caltrans_hq[[1]]\n\n\n# index with the name / subset operator (`$`)\nnamed_list_caltrans_hq$architect\n\n\n\n\nA more realistic example of how a list can store outputs from a model:\n\n# mtcars is a pre-loaded dataset in R #\n\n# fit a linear model\nmodel &lt;- lm(mpg ~ hp, data = mtcars)\n\n# check the type of object\nclass(model) # lm\nis.list(model)\n\n# peek inside the list\nnames(model)\n\n# access model coefficients\nmodel$coefficients\n\n\n\n\n3. Data Frames\nA data frame is a list of equal-length vectors, organized into a two-dimensional tabular structure where:\n\nEach column is a vector.\nAll vectors (columns) must be the same length.\nEach vector can be of a different type (numeric, character, logical, etc.).\n\nA data frame is the most common data structure in R and with tidy data makes data analysis easier.\nTo create a list we use the function data.frame():\n\nladot_employees_df &lt;- data.frame(\n  name = c(\"Mia\", \"Alex\", \"Joe\"),\n  years_employed = c(12, 1, 5),\n  civil_service_appt = c(TRUE, FALSE, TRUE)\n)\n\n\nIndexing Data Frames\nLike vectors and lists, elements within a data frame can be accessed using square brackets. However, unlike vectors and lists, data frames are two-dimensional structures, so elements are accessed using a row and column index in the format [row, column].\n\n\n\n\n\n\nExercise 5: Index a df\n\n\n\n\n\nUsing the ladot_employees_df data frame we created above, pull out the number of years that Mia has been employed.\n\nladot_employees_df[1, 2]\n\n\n\n\n\n\n\n\n\n\nExercise 6: Index a row in a df\n\n\n\n\n\nUsing the ladot_employees_df data frame we created above, access the row for the employee Alex.\nIn a data frame, you can use square brackets [] to access specific rows and columns with the format df[row, column]. If you leave either the row or column index blank, but keep the comma, it tells R to return all rows or all columns, respectively.\n\nladot_employees_df[2,]\n\n\n\n\n\n\n\n\n\n\nExercise 7: Accessing a column vs elements\n\n\n\n\n\nFrom indexing lists, we learned that [] returns a list, while [[]] pulls out the actual elements inside the list. Since a data frame is a special type of list, the same rules apply.\nLet‚Äôs explore this using the years_employed column (the second column in ladot_employees_df):\n\nladot_employees_df[2]\n# check with a logical test\nis.data.frame(ladot_employees_df[2])\n\n# vs\n\nladot_employees_df[[2]]\n# check with a logical test\nis.data.frame(ladot_employees_df[[2]])\nis.vector(ladot_employees_df[[2]])\n\n\n\n\n\n\n\n\n\n\nExercise 8: Updating an element\n\n\n\n\n\nWith indexing, we can also update elements in a data frame by assigning new values using square brackets [].\nLet‚Äôs say Alex‚Äôs civil service appointment was entered incorrectly ‚Äî it should be TRUE instead of FALSE. We can fix that by targeting the specific cell and assigning a new value:\n\n# update civil service appt\nladot_employees_df[2, 3] &lt;- TRUE\n\n\n\n\n\n\n\n\n\n\nBonus! Reproducibility Check\n\n\n\n\n\nLet‚Äôs say we need to save Joe‚Äôs years employed for a future calculation. Consider the two code snippets below:\n\n# option 1: hard code value\njoe_yrs_employed &lt;- 5\n\n# vs\n\n# option 2: index from df\njoe_yrs_employed &lt;- ladot_employees_df$years_employed[3]\n\nWhich one is more reproducible?\n\nOption 2 is the more reproducible choice because it pulls the value directly from your data. If the data changes ‚Äî for example, if Joe‚Äôs years employed is updated, or the number of years is recalculated ‚Äî Option 2 will always reflect the current value.\nOption 1 is risky because it hard-codes a number that may go out of date. It also relies on you remembering where the value came from, which can make your code harder to maintain or audit later.\nWhere Option 2 could break:\n\nIf row order changes (e.g., sorting the data), then ladot_employees_df$years_employed[3] might no longer point to Joe‚Äôs row.\nIf you add or remove rows, the position could shift.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Intro to R Programming</span>"
    ]
  },
  {
    "objectID": "intro-r-programming.html#functions-in-r",
    "href": "intro-r-programming.html#functions-in-r",
    "title": "Intro to R Programming",
    "section": "Functions in R",
    "text": "Functions in R\n\n\n\n\n\n\nWhat‚Äôs a function?\n\n\n\nA function is a self-contained piece of code that takes input(s), performs a specific task, and returns an output\n\n\nR has a large collection of built-in functions, and all functions are called using the same basic syntax:\n\nfunction_name(argument_1 = value_1, argument_2 = value_2, ...)\n\nYou call a function by writing its name, followed by parentheses that include any information the function needs ‚Äî these are called arguments. Arguments are the inputs that tell the function how to do its job. Some functions only need one argument, while others can take several. Knowing what arguments a function expects (and in what order or format) is key to using it effectively and getting the result you want.\n\nHelp Pages\nHow do we learn more about a function and the arguments it takes? We look at the help documentation! This is especially useful when you‚Äôre working with a function you haven‚Äôt used before or want to understand all the available arguments.\nLet‚Äôs open the help page for mean(), type this in your Console:\n\n?mean\n\nThis will open the Help pane in the lower-right corner of RStudio, showing detailed information about the function. Here‚Äôs how the help page is usually organized:\n\nDescription: A short overview of what the function does.\nUsage: The function‚Äôs syntax, including its arguments and default values.\nArguments: A breakdown of what each argument means and expects.\nDetails: Additional context or edge cases to be aware of.\nValue: What the function returns after it runs.\nSee Also: Links to related functions you might want to explore.\nExamples: Ready-to-run code samples that show the function in action.\n\nNeed more help? Many packages include vignettes - detailed guides on how to use their functions. Google package_name vignette (e.g., dplyr vignette) or check the package‚Äôs CRAN page for links.\n\n\n\n\n\n\nBonus: Help with Debugging\n\n\n\nWhen the debugging blues start to hit‚Ä¶reach out for help! I highly recommend the workshop Teach Me How to Google by Sam Csik. It‚Äôs packed with practical tips to level up your troubleshooting game.\nRemember: feeling frustrated and even walking away from your code is totally normal. It‚Äôs all part of the process.",
    "crumbs": [
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Intro to R Programming</span>"
    ]
  },
  {
    "objectID": "cleaning-and-wrangling.html",
    "href": "cleaning-and-wrangling.html",
    "title": "Cleaning & Wrangling",
    "section": "",
    "text": "What is Tidy Data?\nTidy Data is a standardized approach to structuring data tables that makes data management, analysis, and collaboration more efficient, scalable, and reproducible. When we apply Tidy Principles, we can transform messy or inconsistent data into a clean, consistent format that supports faster, more transparent, and more accurate analysis.\nTidy data follows ‚Äúa standard way to organize data values within a dataset.‚Äù The core principles are:\nIt‚Äôs important to note that tidy principles are not tied to R or any specific programming language or software. Rather, they represent a universal approach to organizing data that enhances our ability to work with it effectively‚Äîregardless of the tools we use.\nWhen you encounter a data table for the first time, ask yourself the following questions to determine whether it meets the criteria for tidy data:\nTidy data schematic, from R for Data Science by Grolemund & Wickham.",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Cleaning & Wrangling</span>"
    ]
  },
  {
    "objectID": "cleaning-and-wrangling.html#what-is-tidy-data",
    "href": "cleaning-and-wrangling.html#what-is-tidy-data",
    "title": "Cleaning & Wrangling",
    "section": "",
    "text": "‚ÄúAcknowledgements\n\n\n\nIllustrations in Section 4.1 come from the Openscapes blog Tidy Data for reproducibility, efficiency, and collaboration by Julia Lowndes and Allison Horst.\n\n\n\n\n\n\n\n\n\nAs I move down each column, do all the values represent the same variable?\n\nThink: An attribute that is being measured, counted, or described with data such as year, scooter company, duration or population.\n\nAs I move across each row, do all the values belong to a single observation?\n\nThink: A single ‚Äúdata point‚Äù for which the measure, count or description of one or more variables is recorded. For example, if you are recording variables height, mass, and color of dragons, then each dragon is an observation.\n\nDoes each cell contain only one value?\n\nThink: A single value of the recorded measure, count or description of the variable. We can‚Äôt have multiple values nor marginal sums in a cell.\n\n\n\n\nPractice\n\n\n\n\n\n\nExercise 1\n\n\n\nWhy isn‚Äôt this data ‚Äútidy‚Äù? What would it look like if it was tidy? What might you call the variables?\n\n\n\ncity\ndevice_type\n2005\n2006\n\n\n\n\nLos Angeles\nscooter\n300\n847\n\n\nLos Angeles\ne-bike\n459\n345\n\n\nCulver City\nscooter\n890\n867\n\n\nCulver City\ne-bike\n243\n345\n\n\n\n\n\nAnswer 1\n\nTo make this data tidy, we converted the table from wide to long format.\n\n\n\ncity\ndevice_type\nyear\ntrip_counts\n\n\n\n\nLos Angeles\nscooter\n2005\n300\n\n\nLos Angeles\ne-bike\n2005\n459\n\n\nCulver City\nscooter\n2005\n890\n\n\nCulver City\ne-bike\n2005\n243\n\n\nLos Angeles\nscooter\n2006\n847\n\n\nLos Angeles\ne-bike\n2006\n345\n\n\nCulver City\nscooter\n2006\n867\n\n\nCulver City\ne-bike\n2006\n345\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 2\n\n\n\nWhy isn‚Äôt this data ‚Äútidy‚Äù? What would it look like if it was tidy? What might you call the variables?\n\n\n\nneighborhood\nvariable\nvalue\n\n\n\n\nWest Adams\npopulation\n153,457\n\n\nPico Union\npopulation\n40,000\n\n\nWest Adams\narea\n14.5\n\n\nPico Union\narea\n1.33\n\n\n\n\n\nAnswer 2\n\nTo make this data tidy, we converted the table from long to wide format.\n\n\n\nneighborhood\npopulation\narea_sq_mi\n\n\n\n\nWest Adams\n153,457\n14.5\n\n\nPico Union\n40,000\n1.33",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Cleaning & Wrangling</span>"
    ]
  },
  {
    "objectID": "cleaning-and-wrangling.html#cleaning-wrangling-example",
    "href": "cleaning-and-wrangling.html#cleaning-wrangling-example",
    "title": "Cleaning & Wrangling",
    "section": "Cleaning & Wrangling Example",
    "text": "Cleaning & Wrangling Example\n\n\n\n\n\n\nQuick note on Base R vs tidyverse\n\n\n\nAs you dive deeper into your R programming journey, you will see programmers utilizing Base R or the tidyverse as the framework for their code - or a mix of both!\n\nThe tidyverse refers to a collection of R packages designed for data science, offering a consistent and intuitive way to manipulate, explore, and visualize data, with packages like dplyr, ggplot2, and tidyr.\nBase R refers to the built-in functions that come with the R programming language.\n\n\n\nIn this section, we will take messy data from the real world and programmatically wrangle it into a tidy data table using a handful of tidyverse packages.\n\n\n\n\n\n\nData we‚Äôre working with\n\n\n\nGoal: Turn this messy data into tidy data!\nThis data comes from the U.S. Department of Transportation, Federal Highway Administration. The table compares automobile usage statistics across several countries for the year 1997 (some entries from 1990 and 1991).\n\n\n\nPreview of data from U.S. DOT FHA\n\n\n\n\nR Packages we‚Äôll be using for accessing, tidying, and visualizing the data:\n\n# install packages using `install.packages(\"name_of_package\")`\nlibrary(googlesheets4) # load data\nlibrary(skimr) # explore data\nlibrary(dplyr) # wrangle data\nlibrary(tidyr) # wrangle data\nlibrary(janitor) # `clean_names()`\n\nThe data from U.S. DOT FHA has been recreated in a Google Sheet and can be accessed using the googlesheets4 package. Note: You will have to authenticate your Gmail account before using googlesheets4, you will see a prompt for authentication in the Console when you run the code below.\n\n# \"dat\" = shorthand for \"data\"\nlink_raw_dat = \"https://docs.google.com/spreadsheets/d/1QxmPVLol1Vmxq5f3PFPVr5SyDRFfcwkg6wc-gu0ISVc/edit?usp=sharing\"\nraw_dat &lt;- googlesheets4::read_sheet(link_raw_dat)\n\nBefore working with data, it‚Äôs always important to explore it first! Use the functions below to get familiar with the data. What information did you gain?\n\n# run in the Console #\n\n# prints out the first 5 rows of the data frame\nhead(raw_dat)\n\n# provides a broad overview of a data frame\nskimr::skim(raw_dat)\n\n# opens data in a spreadsheet-style data viewer; \n# the larger the data, the longer it will take to load\nView(raw_dat)\n\nnames() is a useful function that returns the column names of the data frame.\n\nnames(raw_dat)\n\n[1] \"...1\"      \"Japan\"     \"France\"    \"Germany\"   \"Sweden\"    \"U.K.\"     \n[7] \"Canada 1/\" \"Mexico 2/\" \"U.S.\"     \n\n\nThe names of the columns are inconsistent and will be hard to work with in our data wrangling. Let‚Äôs fix that using the clean_names() function from the R package, janitor.\n\n# cn = shorthand for \"clean names\"\ncn_dat &lt;- raw_dat %&gt;% \n  janitor::clean_names()\n\n\n\n\n\n\n\nPipe ( %&gt;% ) Operator\n\n\n\nWe just used the Pipe ( %&gt;% ) Operator for the first time! The pipe is an operator that takes the output of one function and passes it into another function as an argument. It links together all the steps in data analysis making the code more efficient and readable.\nPipe Operator shortcut:\n\nWindows: Ctrl + Shift + M\nMac: Command + Shift + M\n\n\n\nFrom View(), we can tell that our table isn‚Äôt tidy: each column should be a variable, and each row should be one observation, but that‚Äôs not the case here. In the first column (initially unnamed, but janitor::clean_names() provided it with the name x1), we see there are multiple variables. And each row contains data about multiple countries.\n\nReshape data from wide to long\nWe‚Äôll need to reshape the data from wide to long and from long to wide to get it into the right structure.\n\n\n\n\n\n\nSketch it out\n\n\n\nIt can be helpful to draw out what the table should look like after each function and at the end of data wrangling.\nWe‚Äôre first going to reshape the data from wider to longer using tidyr::pivot_longer(). What do you expect the table to look like? What new variable names will we have?\n\n\n\n# what happens when we run this code?\nlong_dat &lt;- cn_dat %&gt;% \n  tidyr::pivot_longer(\n    cols = -x1,\n    names_to = \"country\",\n    values_to = \"value\"\n  )\n\n\n\n\n\n\n\nWe got an Error!\n\n\n\nError in `tidyr::pivot_longer()`:\n! Can't combine `japan` &lt;double&gt; and `canada_1` &lt;list&gt;.\nBacktrace:\n 1. cn_dat %&gt;% ...\n 3. tidyr:::pivot_longer.data.frame(., cols = -x1, names_to = \"country\", values_to = \"value\")\nIt can be scary to when errors come up - but always read the error message! Google will be a helpful friend for deciphering, but over time you‚Äôll gain instincts for understanding what the function needs to run properly.\n\n\nThis error is telling us that it‚Äôs trying to combine columns with incompatible data types, and it‚Äôs not allowed. When we use pivot_longer(), it tries to combine multiple columns into a single column under the hood, but it can‚Äôt merge a column of type double with a column of type list.\nCheck the data type of each column using class() and the subset operator ($) to confirm that the columns japan and canada_1 are different from each other.\n\nclass(cn_dat$japan)\nclass(cn_dat$canada_1)\n\nWe can change a vector or column into a numeric data type using as.numeric(). What data type does canada_1 have now?\n\nwrangle_dat &lt;- cn_dat %&gt;% \n  dplyr::mutate(canada_1 = as.numeric(canada_1))\n\nclass(wrangle_dat$canada_1)\n\n\n\n\n\n\n\nWe got a Warning!\n\n\n\nWarning: There was 1 warning in `dplyr::mutate()`.\n‚Ñπ In argument: `canada_1 = as.numeric(canada_1)`.\nCaused by warning:\n! NAs introduced by coercion\nWarnings can be scary to see too, but they‚Äôre different from errors! A warning means the code successfully ran, but R is giving you a heads-up. That heads-up is saying: ‚ÄúSomething might not have gone exactly as expected, and there may be unexpected or risky behavior in your result.‚Äù\n\n\nIn this case, the warning is telling us that R tried to convert some values to a different type, but some of those values couldn‚Äôt be converted, so R replaced them with NA (missing values).\nLet‚Äôs look more closely at the structure of the column canada_1 to understand what‚Äôs going on.\n\n# `str()` returns the structure of the object\n# esp useful since `canada_1` is a list - shows what‚Äôs inside each element\nstr(cn_dat$canada_1)\n\nList of 5\n $ : num 4.86\n $ : num 0.444\n $ : num 13887270\n $ : num 31281092\n $ : chr \"N/A\"\n\n\n\n\nAdditional functions to use to inspect data\n# best to run these in the Console; not your R Script\nis.na(cn_dat$canada_1)\nskimr::skim(cn_dat$canada_1)\nsummary(cn_dat$canada_1)\nhead(cn_dat$canada_1)\nclass(cn_dat$canada_1)\ntypeof(cn_dat$canada_1)\nView(cn_dat)\n\n\nFrom str(), we can see that the last element in the list is of type chr, or character. Let‚Äôs see what happens when we run as.numeric() on just that value:\n\nas.numeric(\"N/A\")\n\nWe receive the same warning, NAs introduced by coercion. That confirms this character value is likely the cause of the issue.\nWe can replace the character value with a true NA value using na_if() from the dplyr package.\n\nwrangle_dat &lt;- cn_dat %&gt;% \n  dplyr::mutate(canada_1 = dplyr::na_if(x = canada_1, y = \"N/A\"))\n\nLooks like we‚Äôve received another error‚Ä¶this is all part of the data tidying or wrangling process! What is this error trying to tell us?\n\n\n\n\n\n\nError in `dplyr::mutate()`:\n‚Ñπ In argument: `canada_1 = dplyr::na_if(canada_1, \"N/A\")`.\nCaused by error in `dplyr::na_if()`:\n! Can't convert `y` &lt;character&gt; to match type of `x` &lt;list&gt;.\n\ncanada_1 is a list column, not a plain character or numeric vector and ‚ÄúN/A‚Äù is a character string.\nna_if() expects both x and y to be the same type (e.g., both character vectors)\nSince canada_1 is a list, na_if() can‚Äôt compare or replace values the way we want.\n\n\n\n\nWe will need first simplify or flatten the list column into a regular vector using unlist().\n\n# yay, no error!\nwrangle_dat &lt;- cn_dat %&gt;% \n  dplyr::mutate(canada_1 = unlist(canada_1)) %&gt;% \n  dplyr::mutate(canada_1 = dplyr::na_if(canada_1, \"N/A\"))\n\nOkay! Before we could reshape the data with tidyr::pivot_longer(), we had to do a few important data wrangling steps to get things into shape.\nBelow is what those steps look like chained together in a single pipe sequence. It‚Äôs so important to check the state of your data frame after each transformation, so don‚Äôt hesitate to View() or glimpse() between steps to make sure things are being wrangled the way you expect.\n\nlong_dat &lt;- cn_dat %&gt;%\n  # flatten list columns to atomic vector; check the class\n  mutate(canada_1 = unlist(canada_1)) %&gt;% \n  mutate(mexico_2 = unlist(mexico_2)) %&gt;% \n  # replace \"N/A\" strings with true `NA` values; check the class\n  mutate(canada_1 = na_if(canada_1, \"N/A\")) %&gt;% \n  mutate(mexico_2 = na_if(mexico_2, \"N/A\")) %&gt;% \n  # convert character values to numeric; check the class\n  mutate(canada_1 = as.numeric(canada_1),\n         mexico_2 = as.numeric(mexico_2)) %&gt;% \n  # reshape from wide to long format\n  tidyr::pivot_longer(\n    cols = -x1,\n    names_to = \"country\",\n    values_to = \"value\"\n  ) \n\nThis piped sequence also works! We do receive a warning, but that‚Äôs okay as long as we understand what it means and how it affects our data.\nIn this case, the warning is telling us that some values couldn‚Äôt be converted to numeric and were turned into NAs. If we‚Äôre expecting that (e.g., we know there‚Äôs a ‚ÄúN/A‚Äù string or other non-numeric text), then the warning is just a helpful heads-up‚Äînot a blocker.\n\nlong_dat &lt;- cn_dat %&gt;%\n  # convert list cols to numeric (introduces NAs) \n  mutate(canada_1 = as.numeric(canada_1),\n         mexico_2 = as.numeric(mexico_2)) %&gt;% \n  # reshape from wide to long format\n  tidyr::pivot_longer(\n    cols = -x1,\n    names_to = \"country\",\n    values_to = \"value\"\n  ) \n\nWarning: There were 2 warnings in `mutate()`.\nThe first warning was:\n‚Ñπ In argument: `canada_1 = as.numeric(canada_1)`.\nCaused by warning:\n! NAs introduced by coercion\n‚Ñπ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n\n\n\n\nReshape data from long to wide\nThe next step is to reshape the data to wide format by turning the unique values in the x1 column into their own columns, using the corresponding values to fill in the cells. This is useful when you want each unique value in x1 to become a separate variable in your dataset.\nWe‚Äôll use tidyr::pivot_wider() for this:\n\nwider_dat &lt;- long_dat %&gt;% \n  tidyr::pivot_wider(\n    names_from = x1,\n    values_from = value\n  )\n\nWe‚Äôre getting closer to a tidy data frame! As we discussed earlier, including spaces in column names isn‚Äôt ideal and it can lead to messy code and hard-to-read syntax. To clean things up, we‚Äôll use janitor::clean_names() once more to quickly format all our column names into lowercase snake_case.\n\nwider_dat &lt;- wider_dat %&gt;% \n  janitor::clean_names()\n\n\n\nWrangling strings and adding columns\nWe technically now have a tidy data frame (yay!) that meets the tidy data principles, where each column is a variable and each row is an observation.\nHowever, there‚Äôs still a bit of data cleaning we can do to make any future visualizations or analyses go more smoothly and yield more accurate results.\nSpecifically, the country column contains inconsistent naming ‚Äî some values are all lowercase, some include underscores, and some are oddly formatted.\nLet‚Äôs clean this up by first standardizing the values with dplyr::case_when(), and then formatting them nicely using stringr::str_to_title():\n\ntidy_dat &lt;- wider_dat %&gt;%\n  mutate(\n    country = dplyr::case_when(\n      country == \"u_k\" ~ \"united kingdom\",\n      country == \"u_s\" ~ \"united states\",\n      country == \"canada_1\" ~ \"canada\",\n      country == \"mexico_2\" ~ \"mexico\",\n      TRUE ~ country\n    )\n  ) %&gt;%\n  mutate(country = stringr::str_to_title(string = country))\n\nThe final step in our wrangling process is to add a new column, year, to our data frame.\nWhy? Upon further investigation, we discovered that the odd formatting in the country column, specifically for Canada and Mexico, actually referred to footnotes in the original data source. These footnotes indicated that the values for these two countries don‚Äôt come from 1997 like the others. Instead:\n\nCanada‚Äôs data reflects the year 1990\nMexico‚Äôs data reflects the year 1991\n\nTo ensure our dataset accurately represents these differences (and to avoid misleading interpretations in future analyses) we‚Äôll add a year column to capture this context explicitly.\n\ntidy_yearly_dat &lt;- tidy_dat %&gt;%\n  mutate(\n    year = case_when(country == \"Canada\" ~ 1990, \n                     country == \"Mexico\" ~ 1991, TRUE ~ 1997),\n    .before = country\n  )",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Cleaning & Wrangling</span>"
    ]
  },
  {
    "objectID": "cleaning-and-wrangling.html#bonus-visualize-the-tidy-data-frame",
    "href": "cleaning-and-wrangling.html#bonus-visualize-the-tidy-data-frame",
    "title": "Cleaning & Wrangling",
    "section": "Bonus: Visualize the Tidy Data Frame",
    "text": "Bonus: Visualize the Tidy Data Frame\n\n# new column names for table\ntbl_col_names &lt;- c(\n  \"Year\",\n  \"Country\",\n  \"Total Auto VMT per Capita\",\n  \"Autos per Capita\",\n  \"# of Autos\",\n  \"Population\",\n  \"Auto VMT (thousands)\"\n  )\n\n# convert `year` to a factor so it's not treated as numeric in `format.args`\ntbl_dat &lt;- tidy_yearly_dat %&gt;% \n  mutate(year = as.factor(year))\n\nknitr::kable(tbl_dat,\n             col.names = tbl_col_names,\n             align = \"c\",\n             format.args = list(big.mark = \",\")) %&gt;% \n  kableExtra::kable_styling(full_width = F)\n\n\n\n\nYear\nCountry\nTotal Auto VMT per Capita\nAutos per Capita\n# of Autos\nPopulation\nAuto VMT (thousands)\n\n\n\n\n1997\nJapan\n2.368\n0.394\n49,896,326\n126,549,976\n299,721,118\n\n\n1997\nFrance\n4.209\n0.463\n27,480,000\n59,329,691\n249,689,411\n\n\n1997\nGermany\n3.961\n0.511\n42,323,672\n82,797,408\n327,950,311\n\n\n1997\nSweden\n3.989\n0.436\n3,867,000\n8,873,052\n35,398,758\n\n\n1997\nUnited Kingdom\n3.967\n0.372\n22,115,000\n59,511,464\n236,086,957\n\n\n1990\nCanada\n4.859\n0.444\n13,887,270\n31,281,092\nNA\n\n\n1991\nMexico\n0.243\n0.098\n9,842,006\n100,349,766\nNA\n\n\n1997\nUnited States\n5.701\n0.481\n132,432,044\n275,562,673\n1,570,973,292",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Cleaning & Wrangling</span>"
    ]
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "Resources",
    "section": "",
    "text": "Online Books",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#online-books",
    "href": "resources.html#online-books",
    "title": "Resources",
    "section": "",
    "text": "R for Data Science (2e) by Hadley Wickham, Mine √áetinkaya-Rundel & Garrett Grolemund\nPython4DS by Arthur Turrell, et al.\nNational Center for Ecological Analysis & Snythesis (NCEAS) Training Materials Catalog",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#blogs-bloggers-papers---oh-my",
    "href": "resources.html#blogs-bloggers-papers---oh-my",
    "title": "Resources",
    "section": "Blogs, Bloggers & Papers - Oh my!",
    "text": "Blogs, Bloggers & Papers - Oh my!\n\nTidy data by Hadley Wickham published in The Journal of Statistical Software, vol.¬†59, 2014.\n\nTL;DR version on the Comprehensive R Archive Network (CRAN)\n\nFrom Data to Viz\nColor Brewer 2.0\nSam Shanny-Csik\nData is Plural\n3 Minutes Wednesdays\nAllison Horst\nAlison Hill\nDanielle Navarro\nBeatriz Milz",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#communities",
    "href": "resources.html#communities",
    "title": "Resources",
    "section": "Communities",
    "text": "Communities\n\nR-Ladies Los Angeles Meetup\nMinorities in R (MiR) Slack Community\nTidyTuesday Community Activity hosted by Data Science Learning Community\nOpenscapes\nROpenSci",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "resources.html#cheatsheets",
    "href": "resources.html#cheatsheets",
    "title": "Resources",
    "section": "Cheatsheets",
    "text": "Cheatsheets\n\nPosit Cheatsheets\nReproducibility Checklist",
    "crumbs": [
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Resources</span>"
    ]
  },
  {
    "objectID": "cleaning-and-wrangling.html#exporting-data",
    "href": "cleaning-and-wrangling.html#exporting-data",
    "title": "Cleaning & Wrangling",
    "section": "Exporting Data",
    "text": "Exporting Data\nYay, we have our new tidy data table! It‚Äôs ready for analysis and for sharing. To export a table created in R, we use the readr::write_*() family of functions. The readr package provides several options for saving data in different file formats.\nIn the code chunk below, we use write_csv() to save our tidy data table as a .csv file. This function takes two main arguments:\n\nthe data object you want to save (in this case, tidy_yearly_dat)\nthe file path where you want the file saved (we use here::here() to create a robust and reproducible path across different systems).\n\n\n\n\n\n\n\nAccessing the Help Page\n\n\n\nYou can view the documentation by running ?write_csv or ?readr::write_csv in the Console.\n\n\n\nreadr::write_csv(tidy_yearly_dat,\n                 file = here::here(\"data\", \"tidy_yearly_dat.csv\"))",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Cleaning & Wrangling</span>"
    ]
  },
  {
    "objectID": "hh-exercise-palmer-penguins.html",
    "href": "hh-exercise-palmer-penguins.html",
    "title": "Hacky Hours Exercise: Palmer Penguins Practice",
    "section": "",
    "text": "About the Data\n\n\n\nThe Palmer Penguins dataset comes from the palmerpenguins R package. It was created as an educational alternative to the classic iris dataset and provides real-world data collected by Dr.¬†Kristen Gorman from the Palmer Station, Antarctica Long Term Ecological Research Network (LTER) site. The dataset includes data for 344 penguins from three different species, collected across three islands in the Palmer Archipelago, Antarctica.‚Äù\n\n\n\n0. Load libraries + data\n\n\n\n\n\n\nA few reminders:\n\n\n\n\nBefore you begin, ask yourself: WHERE AM I?\nLet your code b r e a t h e, align code vertically, and use a consistent naming convention!\nUse # to create a comment in an R Script\nUse ---- to create new ‚Äúheaders‚Äù in an R Script after a comment\nPipe Operator shortcut: Ctrl + Shift + M\n\n\n\nInstall the R package palmerpenguins, if you haven‚Äôt already:\n\ninstall.packages(\"palmerpenguins\")\n\nThese are following libraries we‚Äôll use for these exercises:\n\nlibrary(palmerpenguins) # access penguins data\nlibrary(skimr) # summarize data\nlibrary(tidyr) # allows us to use the pipe (%&gt;%)\nlibrary(dplyr) # cleaning and wrangling functions\n\nAccess the penguin data by referencing penguins from the palmerpenguins package in your code or function arguments.\nUse palmerpenguins::penguins to access the dataset directly from the palmerpenguins package without loading the package with library().\n\n# if package is loaded:\nView(penguins)\n\n# without loading package:\nView(palmerpenguins::penguins)\n\n\n\n1. Explore your data\nCall the following functions in the Console to get familiar with and explore your data:\n\nView() # opens data as a spreadsheet-style data viewer in the Source Pane\nskimr::skim() # alternative to `summary()` providing broad overview of dataframe\nnames() # prints out all the names of an object\nhead() # returns first 6 rows of df; useful for large data\nstr() # returns structure of an R object; another alt to `summary()`\nglimpse() # alt to `str()`; may be more readable for you\nunique() # use in combo w/ subset operator ($) to see unique values in a column\ndim() # returns dimensions (# rows, # cols) of df or use `nrow()` or `ncol()`\nanyNA() # check for NAs\ncolSums(is.na()) # counts number of NAs in each column\n\n\n\n2. Subsetting\n\n\n\n\n\n\nExercise A\n\n\n\nCreate a new R object called annual_penguinsand use dplyr::select() to create a subset containing the columns: species, island, sex, and year.\n\n\n\n\nAnswer\nannual_penguins &lt;- penguins %&gt;% \n  select(species,\n         island,\n         sex,\n         year)\n\n\n\n\n\n\n\n\nExercise B\n\n\n\nIn the annual_penguins data frame, use dplyr::filter() to create a subset containing only female penguins. You come up with a new object name!\n\n\n\n\nAnswer\nfemale_penguins &lt;- annual_penguins %&gt;% \n  filter(sex == \"female\")\n\n\n\n\n\n\n\n\nExercise C\n\n\n\nStarting from the data frame you created in Exercise B, use filter() to further narrow or subset the data to only Adelie penguins.\n\n\n\n\nAnswer\nfemale_adelie_penguins &lt;- annual_penguins %&gt;% \n  filter(sex == \"female\" & species == \"Adelie\")\n\n# this is also valid\nfemale_adelie_penguins &lt;- annual_penguins %&gt;% \n  filter(sex == \"female\") %&gt;% \n  filter(species == \"Adelie\")\n\n# ~ Note: ~ #\n# You can combine multiple conditions inside a single `filter()` using & (and), or you can chain multiple `filter()` calls using the pipe (%&gt;%). \n# Both approaches produce the same result.\n# Chaining filters can sometimes improve readability, especially when applying several filtering steps\n\n\n\n\n3. Calculating\n\n\n\n\n\n\nExercise A\n\n\n\nCreate a new column using dplyr::mutate() that is the ratio of bill length to bill depth. Hint: Ratio = bill_length_mm / bill_depth_mm\n\n\n\n\nAnswer\npenguins_bill_ratio &lt;- penguins %&gt;% \n  mutate(bill_ratio = bill_length_mm / bill_depth_mm,\n         .after = bill_depth_mm)\n\n# ~ Note ~ #\n# Recall we can use `.after` or `.before` to specify the new col position\n\n\n\n\n\n\n\n\nExercise B\n\n\n\nCalculate the mean body mass (in grams) for each penguin species. To do this, you will be using two new functions: dplyr::group_by() and dplyr::summarize().\nUse the ?group_by and ?summarise Help Pages or search online for examples if you get stuck.\nThe result should be a summary table with one row per species and the average body mass for each.\n\n\n\n\n\n\n\n\nsummarize() vs summarise()\n\n\n\n\n\nYou might notice that dplyr also has the function summarise(). Both summarise() and summarize() work exactly the same and are aliases for each other. The only difference is American vs English spelling - whichever one you use, be consistent!\n\n\n\n\n\nAnswer\npenguins_mean_body_mass &lt;- penguins %&gt;%\n  group_by(species) %&gt;%\n  summarize(mean_body_mass_g = mean(body_mass_g, na.rm = TRUE))\n\n# ~ Reflections ~ # \n# How do the species compare in terms of average body mass?\n# What happens if you only run the `group_by()` line without summarizing?\n# We use `na.rm = TRUE` to ignore missing values. What happens if we don‚Äôt include it?\n\n\n\n\n\n\n\n\nExercise C\n\n\n\nCalculate the average flipper length in millimeters for penguins on each island. Again, you will be using the functions: dplyr::group_by() and dplyr::summarize().\nThe result should be a summary table with one row per species and the average flipper length in millimeters for each.\n\n\n\n\nAnswer\nmean_flipper_length_by_island &lt;- penguins %&gt;%\n  group_by(island) %&gt;%\n  summarize(mean_flipper_length_mm = mean(flipper_length_mm, na.rm = TRUE))\n\n# ~ Reflections ~ # \n# How does flipper length compare across islands?\n# How would the result change if you grouped by species instead of island?\n\n\n\n\n4. Enhancing (Transforming)\n\n\n\n\n\n\nExercise A\n\n\n\nConsider what you learned about the size of the penguins from Exercises B & C from the Calculating section.\nAdd a new column called size that categorizes each penguin as ‚Äúsmall‚Äù, ‚Äúmedium‚Äù, or ‚Äúlarge‚Äù based on its species. Use mutate() and case_when() from dplyr.\n\n\n\n\nAnswer\nenhanced_penguins &lt;- penguins %&gt;%\n  mutate(size = case_when(\n    species == \"Adelie\" ~ \"small\",\n    species == \"Chinstrap\" ~ \"medium\",\n    species == \"Gentoo\" ~ \"large\",\n    TRUE ~ NA_character_  # all other species get value of NA\n  ))\n\n# ~ Note ~ #\n# `NA` is used for missing values\n# `NA_character_` is used when working with character columns to ensure the type of missing value is consistent with the column's data type \n# With `NA`, the data type is assumed to be logical and could result in an error",
    "crumbs": [
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Hacky Hours Exercise: Palmer Penguins Practice</span>"
    ]
  }
]